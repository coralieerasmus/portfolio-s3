    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="index.css">
        <title>Interactive Organic Gradient</title>
    </head>
    <body>
        <main>
            <h1 class = "landing-heading">
                <span class = "landing-heading-line"> Coralie Erasmus</span>
                <span class = "landing-heading-line"> Portfolio - S3</span>
            </h1>
        </main>
        <style>
            body {
        margin: 0;
        overflow: hidden;
    }

    canvas {
        display: block;
    }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="index.js" defer></script>
        <script>
                // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a fullscreen plane
        const geometry = new THREE.PlaneGeometry(2, 2);

        // Shader material
        const material = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { value: 0.0 },
                u_mouse: { value: new THREE.Vector2(0.5, 0.5) },
                u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                void main() {
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float u_time;
                uniform vec2 u_mouse;
                uniform vec2 u_resolution;

                // Simplex noise function
                float random(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    vec2 u = f * f * (3.0 - 2.0 * f);

                    return mix(
                        mix(random(i), random(i + vec2(1.0, 0.0)), u.x),
                        mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x),
                        u.y
                    );
                }

                void main() {
                    vec2 st = gl_FragCoord.xy / u_resolution.xy;

                    // Normalize mouse influence
                    vec2 mouseNorm = u_mouse / u_resolution;
                    vec2 p = st * 2.0 - 1.0;

                    // Apply time-based noise distortion for fluid movement
                    float n = noise(p * 3.0 + u_time * 1.0); // Adjusted dynamic movement speed
                    float m = noise(p * 2.0 - u_time * 0.8 + mouseNorm * 2.0); // Mouse influence with movement

                    // Sunset-inspired color blending with clearer distinctions
                    vec3 color1 = vec3(1.0, 0.4, 0.1); // Vibrant orange (sunset base)
                    vec3 color2 = vec3(1.0, 0.8, 0.2); // Soft yellow (highlight)
                    vec3 color3 = vec3(0.6, 0.1, 0.6); // Deep purple (twilight)
                    vec3 color4 = vec3(0.1, 0.3, 0.8); // Cool blue (fading daylight)
                    
                    // Maintain clear transitions and subtle movement
                    vec3 color = mix(color1, color2, smoothstep(0.0, 1.0, n));  // Orange to Yellow
                    color = mix(color, color3, smoothstep(0.0, 1.0, m)); // Yellow to Purple
                    color = mix(color, color4, smoothstep(0.0, 1.0, abs(n - m))); // Purple to Blue

                    // Allow colors to move fluidly without overpowering one another
                    vec2 fluidMovement = vec2(sin(u_time * 0.5), cos(u_time * 0.5)); // Directional fluid motion
                    color += 0.2 * sin(u_time + fluidMovement.x + fluidMovement.y); // Subtle fluid effect

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        // Set up camera position
        camera.position.z = 1;

        // Track mouse movement
        window.addEventListener('mousemove', (event) => {
            material.uniforms.u_mouse.value.set(event.clientX, event.clientY);
        });

        // Handle resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const animate = function () {
            requestAnimationFrame(animate);
            material.uniforms.u_time.value += 0.01; // Controlled time increment for liquid movement
            renderer.render(scene, camera);
        };

        animate();
        </script>
    </body>
    </html>
